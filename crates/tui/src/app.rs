mod onboarding;

use {
    crate::{
        Error,
        connection::{ConnectionEvent, ConnectionManager},
        events,
        onboarding::{OnboardingState, ProviderEntry, parse_providers},
        rpc::RpcClient,
        state::{
            AppState, DisplayMessage, InputMode, MainTab, MessageRole, ModelSwitchItem,
            ModelSwitcherState, Panel, SessionEntry, SlashMenuItem, TokenUsage,
        },
        ui::{self, status_bar::ConnectionDisplay, theme::Theme},
    },
    crossterm::event::{Event, EventStream, KeyCode, KeyEvent, KeyModifiers},
    futures::StreamExt,
    moltis_protocol::ConnectAuth,
    ratatui::DefaultTerminal,
    serde_json::Value,
    std::{collections::HashSet, sync::Arc, time::Duration},
    tokio::sync::mpsc,
    tracing::{debug, warn},
    tui_textarea::TextArea,
};

/// Events that drive the application state machine.
#[derive(Debug)]
pub enum AppEvent {
    /// Terminal key press.
    Key(KeyEvent),
    /// Terminal resize or focus-regained â€” forces a full redraw.
    Redraw,
    /// Periodic tick for animations/status updates.
    Tick,
    /// Connection lifecycle event.
    Connection(ConnectionEvent),
    /// Initial data loaded from gateway (non-blocking).
    InitialData(InitialData),
    /// System message generated by an async task.
    SystemMessage(String),
    /// Context payload returned by `/context`.
    ContextData(Value),
}

/// Data loaded from the gateway after a successful connection.
#[derive(Debug, Default)]
pub struct InitialData {
    pub sessions: Option<Vec<SessionEntry>>,
    pub messages: Option<Vec<DisplayMessage>>,
    pub active_session: Option<String>,
    pub model: Option<String>,
    pub provider: Option<String>,
    pub token_usage: Option<TokenUsage>,
}

#[derive(Debug, Clone, PartialEq, Eq)]
struct SlashCommand {
    name: String,
    args: String,
}

#[derive(Debug, Clone, Copy)]
struct SlashCommandSpec {
    name: &'static str,
    description: &'static str,
}

const SLASH_COMMANDS: [SlashCommandSpec; 5] = [
    SlashCommandSpec {
        name: "clear",
        description: "Clear conversation history",
    },
    SlashCommandSpec {
        name: "compact",
        description: "Summarize conversation to save tokens",
    },
    SlashCommandSpec {
        name: "context",
        description: "Show session context and project info",
    },
    SlashCommandSpec {
        name: "sh",
        description: "Enter command mode (/sh off or Esc to exit)",
    },
    SlashCommandSpec {
        name: "help",
        description: "Show slash command list",
    },
];

/// Top-level application.
pub struct App {
    state: AppState,
    onboarding: Option<OnboardingState>,
    model_switcher: Option<ModelSwitcherState>,
    onboarding_check_pending: bool,
    connection_display: ConnectionDisplay,
    connection: Option<Arc<ConnectionManager>>,
    should_quit: bool,
    url: String,
    auth: ConnectAuth,
    theme: Theme,
}

impl App {
    pub fn new(url: String, auth: ConnectAuth) -> Self {
        Self {
            state: AppState::default(),
            onboarding: None,
            model_switcher: None,
            onboarding_check_pending: true,
            connection_display: ConnectionDisplay::Connecting,
            connection: None,
            should_quit: false,
            url,
            auth,
            theme: Theme::default(),
        }
    }

    /// Main event loop: reads terminal events, dispatches, and re-renders.
    pub async fn run(mut self, mut terminal: DefaultTerminal) -> Result<(), Error> {
        let (event_tx, mut event_rx) = mpsc::unbounded_channel::<AppEvent>();

        // Spawn terminal event reader
        let term_tx = event_tx.clone();
        tokio::spawn(async move {
            let mut reader = EventStream::new();
            while let Some(Ok(event)) = reader.next().await {
                let app_event = match event {
                    Event::Key(key) => AppEvent::Key(key),
                    Event::Resize(..) | Event::FocusGained => AppEvent::Redraw,
                    _ => continue,
                };
                if term_tx.send(app_event).is_err() {
                    break;
                }
            }
        });

        // Spawn tick timer (60ms for smooth streaming)
        let tick_tx = event_tx.clone();
        tokio::spawn(async move {
            let mut interval = tokio::time::interval(Duration::from_millis(60));
            loop {
                interval.tick().await;
                if tick_tx.send(AppEvent::Tick).is_err() {
                    break;
                }
            }
        });

        // Spawn connection manager
        let (conn_event_tx, mut conn_event_rx) = mpsc::unbounded_channel::<ConnectionEvent>();
        let connection = Arc::new(ConnectionManager::spawn(
            self.url.clone(),
            self.auth.clone(),
            conn_event_tx,
        ));
        let rpc = Arc::new(RpcClient::new(Arc::clone(&connection)));
        self.connection = Some(Arc::clone(&connection));

        // Forward connection events to main event loop
        let conn_fwd_tx = event_tx.clone();
        let rpc_resolver = Arc::clone(&rpc);
        tokio::spawn(async move {
            while let Some(event) = conn_event_rx.recv().await {
                match event {
                    ConnectionEvent::Frame(text) => {
                        // Resolve RPC responses off the UI thread so `rpc.call()`
                        // can complete even while the app loop is busy.
                        if let Ok(response) =
                            serde_json::from_str::<moltis_protocol::ResponseFrame>(&text)
                            && response.r#type == "res"
                        {
                            rpc_resolver.resolve_response(response).await;
                            continue;
                        }

                        if conn_fwd_tx
                            .send(AppEvent::Connection(ConnectionEvent::Frame(text)))
                            .is_err()
                        {
                            break;
                        }
                    },
                    other => {
                        if conn_fwd_tx.send(AppEvent::Connection(other)).is_err() {
                            break;
                        }
                    },
                }
            }
        });

        // Text input area
        let mut textarea = TextArea::default();
        textarea.set_placeholder_text("Type a message...");

        // Main loop
        while !self.should_quit {
            if self.state.dirty {
                terminal.draw(|frame| {
                    ui::draw(
                        frame,
                        &self.state,
                        self.onboarding.as_ref(),
                        self.model_switcher.as_ref(),
                        self.onboarding_check_pending,
                        &self.connection_display,
                        &mut textarea,
                        &self.theme,
                    );
                })?;
                self.state.dirty = false;
            }

            if let Some(event) = event_rx.recv().await {
                self.handle_event(event, &rpc, &event_tx, &mut textarea)
                    .await;
            }
        }

        Ok(())
    }

    async fn handle_event(
        &mut self,
        event: AppEvent,
        rpc: &Arc<RpcClient>,
        event_tx: &mpsc::UnboundedSender<AppEvent>,
        textarea: &mut TextArea<'_>,
    ) {
        match event {
            AppEvent::Key(key) => self.handle_key(key, rpc, event_tx, textarea).await,
            AppEvent::Redraw => {
                self.state.dirty = true;
            },
            AppEvent::Tick => {
                // Re-render on tick if streaming (for spinner animation)
                if self.state.is_streaming() || self.state.pending_approval.is_some() {
                    self.state.dirty = true;
                }
            },
            AppEvent::Connection(conn_event) => {
                self.handle_connection_event(conn_event, rpc, event_tx)
                    .await;
            },
            AppEvent::InitialData(data) => {
                self.apply_initial_data(data);
            },
            AppEvent::SystemMessage(content) => {
                self.push_system_message(content);
            },
            AppEvent::ContextData(payload) => {
                self.apply_context_snapshot(&payload);
                self.push_system_message(format_context_summary(&payload));
            },
        }
    }

    async fn handle_connection_event(
        &mut self,
        event: ConnectionEvent,
        rpc: &Arc<RpcClient>,
        event_tx: &mpsc::UnboundedSender<AppEvent>,
    ) {
        match event {
            ConnectionEvent::Connected(hello_ok) => {
                self.connection_display = ConnectionDisplay::Connected;
                self.state.server_version = Some(hello_ok.server.version.clone());
                self.state.dirty = true;

                if self.initialize_onboarding(rpc).await {
                    // Load sessions and history in background (non-blocking).
                    spawn_initial_data_load(Arc::clone(rpc), event_tx.clone());
                }
                self.onboarding_check_pending = false;
                self.state.dirty = true;
            },
            ConnectionEvent::Disconnected => {
                self.connection_display = ConnectionDisplay::Disconnected;
                self.state.active_run_id = None;
                self.state.thinking_active = false;
                self.onboarding_check_pending = false;
                self.state.dirty = true;
            },
            ConnectionEvent::Error(msg) => {
                self.connection_display = ConnectionDisplay::Disconnected;
                self.onboarding_check_pending = false;
                // Provide actionable hints for common errors.
                let content = if msg.contains("authentication failed") {
                    "Authentication failed. Run the gateway's web UI to complete \
                     setup, or pass --api-key."
                        .into()
                } else {
                    format!("Connection error: {msg}")
                };
                self.state.messages.push(DisplayMessage {
                    role: MessageRole::System,
                    content,
                    tool_calls: Vec::new(),
                    thinking: None,
                });
                self.state.dirty = true;
            },
            ConnectionEvent::Frame(text) => {
                self.handle_frame(&text);
            },
        }
    }

    fn handle_frame(&mut self, text: &str) {
        // Try as event frame
        if let Ok(event) = serde_json::from_str::<moltis_protocol::EventFrame>(text)
            && event.r#type == "event"
        {
            let payload = event.payload.unwrap_or(Value::Null);
            events::handle_event(&mut self.state, &event.event, &payload);
        }
    }

    fn apply_initial_data(&mut self, data: InitialData) {
        if let Some(sessions) = data.sessions {
            self.state.sessions = sessions;
        }
        if let Some(messages) = data.messages {
            self.state.messages = messages;
        }
        if let Some(session) = data.active_session {
            self.state.active_session = session;
        }
        if data.model.is_some() {
            self.state.model = data.model;
        }
        if data.provider.is_some() {
            self.state.provider = data.provider;
        }
        if let Some(usage) = data.token_usage {
            self.state.token_usage = usage;
        }
        self.state.dirty = true;
    }

    fn push_system_message(&mut self, content: String) {
        self.state.messages.push(DisplayMessage {
            role: MessageRole::System,
            content,
            tool_calls: Vec::new(),
            thinking: None,
        });
        self.state.scroll_to_bottom();
        self.state.dirty = true;
    }

    fn apply_context_snapshot(&mut self, payload: &Value) {
        if let Some(session) = payload.get("session") {
            if let Some(key) = session.get("key").and_then(Value::as_str) {
                self.state.active_session = key.to_string();
            }
            self.state.model = session
                .get("model")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned);
            self.state.provider = session
                .get("provider")
                .and_then(Value::as_str)
                .map(ToOwned::to_owned);
        }
        self.state.token_usage = parse_token_usage(payload);
    }

    fn clear_slash_menu(&mut self) {
        if self.state.slash_menu_items.is_empty() && self.state.slash_menu_selected == 0 {
            return;
        }
        self.state.slash_menu_items.clear();
        self.state.slash_menu_selected = 0;
        self.state.dirty = true;
    }

    fn update_slash_menu(&mut self, textarea: &TextArea<'_>) {
        let text = textarea.lines().join("\n");
        let menu = build_slash_menu_items(&text);
        if menu.is_empty() {
            self.clear_slash_menu();
            return;
        }

        let previous_name = self
            .state
            .slash_menu_items
            .get(self.state.slash_menu_selected)
            .map(|item| item.name.clone());
        self.state.slash_menu_items = menu;
        self.state.slash_menu_selected = previous_name
            .and_then(|name| {
                self.state
                    .slash_menu_items
                    .iter()
                    .position(|item| item.name == name)
            })
            .unwrap_or(0);
        self.state.dirty = true;
    }

    fn move_slash_menu_selection(&mut self, forward: bool) {
        let len = self.state.slash_menu_items.len();
        if len == 0 {
            self.state.slash_menu_selected = 0;
            return;
        }
        if forward {
            self.state.slash_menu_selected = (self.state.slash_menu_selected + 1) % len;
        } else {
            self.state.slash_menu_selected = (self.state.slash_menu_selected + len - 1) % len;
        }
        self.state.dirty = true;
    }

    async fn apply_slash_menu_selection(
        &mut self,
        rpc: &Arc<RpcClient>,
        event_tx: &mpsc::UnboundedSender<AppEvent>,
        textarea: &mut TextArea<'_>,
    ) {
        let command_name = self
            .state
            .slash_menu_items
            .get(self.state.slash_menu_selected)
            .map(|item| item.name.clone());
        let Some(command_name) = command_name else {
            return;
        };
        let command = format!("/{command_name}");
        if self.handle_slash_command(&command, rpc, event_tx).await {
            *textarea = TextArea::default();
            textarea.set_placeholder_text("Type a message...");
            self.clear_slash_menu();
            self.state.dirty = true;
        }
    }

    async fn handle_key(
        &mut self,
        key: KeyEvent,
        rpc: &Arc<RpcClient>,
        event_tx: &mpsc::UnboundedSender<AppEvent>,
        textarea: &mut TextArea<'_>,
    ) {
        if let Some(onboarding) = self.onboarding.as_ref() {
            let modal_open = onboarding_modal_open(onboarding);
            if should_quit_onboarding(key, modal_open) {
                self.should_quit = true;
                return;
            }
        }

        if self.onboarding_check_pending {
            if should_quit_onboarding(key, false) {
                self.should_quit = true;
            }
            return;
        }

        if self.model_switcher.is_some() {
            self.handle_model_switcher_key(key, rpc).await;
            return;
        }

        match self.state.input_mode {
            InputMode::Normal => self.handle_normal_key(key, rpc, textarea).await,
            InputMode::Insert => self.handle_insert_key(key, rpc, event_tx, textarea).await,
            InputMode::Command => self.handle_command_key(key, rpc),
        }
    }

    async fn handle_normal_key(
        &mut self,
        key: KeyEvent,
        rpc: &Arc<RpcClient>,
        textarea: &mut TextArea<'_>,
    ) {
        if self.onboarding.is_some() {
            self.handle_onboarding_normal_key(key, rpc, textarea).await;
            return;
        }

        match (key.code, key.modifiers) {
            // Quit
            (KeyCode::Char('c'), KeyModifiers::CONTROL) => {
                if self.state.is_streaming() {
                    // Abort current stream
                    rpc.fire_and_forget(
                        "chat.abort",
                        serde_json::json!({"sessionKey": self.state.active_session}),
                    );
                    self.state.active_run_id = None;
                    self.state.thinking_active = false;
                    self.state.dirty = true;
                } else {
                    self.should_quit = true;
                }
            },
            (KeyCode::Char('q'), _) => {
                if self.state.pending_approval.is_none() {
                    self.should_quit = true;
                }
            },

            // Enter insert mode
            (KeyCode::Char('i') | KeyCode::Char('a'), _) => {
                self.state.input_mode = InputMode::Insert;
                self.state.dirty = true;
            },

            // Enter command mode
            (KeyCode::Char(':'), _) => {
                self.state.input_mode = InputMode::Command;
                self.state.command_buffer.clear();
                self.state.dirty = true;
            },

            // Model/provider switcher
            (KeyCode::Char('m'), KeyModifiers::NONE) => {
                self.open_model_switcher(rpc).await;
            },

            // Scrolling
            (KeyCode::Char('j') | KeyCode::Down, _) => {
                self.state.scroll_down(1);
            },
            (KeyCode::Char('k') | KeyCode::Up, _) => {
                self.state.scroll_up(1);
            },
            (KeyCode::Char('d'), KeyModifiers::CONTROL) => {
                self.state.scroll_down(10);
            },
            (KeyCode::Char('u'), KeyModifiers::CONTROL) => {
                self.state.scroll_up(10);
            },
            (KeyCode::Char('g'), _) => {
                // Scroll to top
                self.state.scroll_offset = usize::MAX;
                self.state.dirty = true;
            },
            (KeyCode::Char('G'), KeyModifiers::SHIFT) | (KeyCode::End, _) => {
                self.state.scroll_to_bottom();
            },

            // Toggle sidebar
            (KeyCode::Char('b'), KeyModifiers::CONTROL) => {
                self.state.sidebar_visible = !self.state.sidebar_visible;
                self.state.dirty = true;
            },

            // Tab: cycle focus (Chat tab only)
            (KeyCode::Tab, _) => {
                if matches!(self.state.active_tab, MainTab::Chat) {
                    self.state.active_panel = match self.state.active_panel {
                        Panel::Chat => Panel::Sessions,
                        Panel::Sessions => Panel::Chat,
                    };
                    if self.state.active_panel == Panel::Sessions {
                        self.state.sidebar_visible = true;
                    }
                }
                self.state.dirty = true;
            },

            // Tab navigation: 1-4 switch tabs
            (KeyCode::Char('1'), _) if self.state.pending_approval.is_none() => {
                self.state.active_tab = MainTab::Chat;
                self.state.dirty = true;
            },
            (KeyCode::Char('2'), _) if self.state.pending_approval.is_none() => {
                self.state.active_tab = MainTab::Settings;
                self.state.dirty = true;
            },
            (KeyCode::Char('3'), _) if self.state.pending_approval.is_none() => {
                self.state.active_tab = MainTab::Projects;
                self.state.dirty = true;
            },
            (KeyCode::Char('4'), _) if self.state.pending_approval.is_none() => {
                self.state.active_tab = MainTab::Crons;
                self.state.dirty = true;
            },

            // Approval handling
            (KeyCode::Char('y'), _) => {
                if let Some(approval) = self.state.pending_approval.take() {
                    rpc.fire_and_forget(
                        "exec.approval.resolve",
                        serde_json::json!({
                            "requestId": approval.request_id,
                            "decision": "approved"
                        }),
                    );
                    self.state.dirty = true;
                }
            },
            (KeyCode::Char('n'), _) => {
                if let Some(approval) = self.state.pending_approval.take() {
                    rpc.fire_and_forget(
                        "exec.approval.resolve",
                        serde_json::json!({
                            "requestId": approval.request_id,
                            "decision": "denied"
                        }),
                    );
                    self.state.dirty = true;
                }
            },

            _ => {},
        }
    }

    async fn open_model_switcher(&mut self, rpc: &Arc<RpcClient>) {
        let (providers_res, models_res) = tokio::join!(
            rpc.call("providers.available", serde_json::json!({})),
            rpc.call("models.list", serde_json::json!({})),
        );

        let providers = providers_res
            .ok()
            .map(|payload| parse_providers(&payload))
            .unwrap_or_default();
        let models = models_res
            .ok()
            .map(|payload| parse_model_list(&payload))
            .unwrap_or_default();
        let items = build_model_switch_items(&providers, &models);

        if items.is_empty() {
            self.state.messages.push(DisplayMessage {
                role: MessageRole::System,
                content: "No configured providers with visible models. Configure a provider first."
                    .to_string(),
                tool_calls: Vec::new(),
                thinking: None,
            });
            self.state.dirty = true;
            return;
        }

        let current_provider = self
            .state
            .provider
            .as_deref()
            .unwrap_or_default()
            .to_string();
        let current_model = self.state.model.as_deref().unwrap_or_default().to_string();
        let selected = items
            .iter()
            .position(|item| {
                item.model_id == current_model
                    && (current_provider.is_empty()
                        || provider_names_match(&item.provider_name, &current_provider)
                        || item
                            .provider_display
                            .eq_ignore_ascii_case(&current_provider))
            })
            .or_else(|| items.iter().position(|item| item.model_id == current_model))
            .unwrap_or(0);

        self.model_switcher = Some(ModelSwitcherState {
            query: String::new(),
            selected,
            items,
            error_message: None,
        });
        self.state.dirty = true;
    }

    async fn handle_model_switcher_key(&mut self, key: KeyEvent, rpc: &Arc<RpcClient>) {
        if is_force_quit_key(key) {
            self.should_quit = true;
            return;
        }

        match key.code {
            KeyCode::Esc => {
                self.model_switcher = None;
                self.state.dirty = true;
                return;
            },
            KeyCode::Enter => {
                self.apply_model_switch_selection(rpc).await;
                return;
            },
            _ => {},
        }

        let Some(switcher) = self.model_switcher.as_mut() else {
            return;
        };

        match (key.code, key.modifiers) {
            (KeyCode::Backspace, _) => {
                switcher.query.pop();
                switcher.error_message = None;
                sync_model_switcher_selection(switcher);
                self.state.dirty = true;
            },
            (KeyCode::Char('j') | KeyCode::Down, _) => {
                move_model_switcher_selection(switcher, true);
                self.state.dirty = true;
            },
            (KeyCode::Char('k') | KeyCode::Up, _) => {
                move_model_switcher_selection(switcher, false);
                self.state.dirty = true;
            },
            (KeyCode::Char(c), modifiers)
                if !c.is_control()
                    && !modifiers.contains(KeyModifiers::CONTROL)
                    && !modifiers.contains(KeyModifiers::ALT) =>
            {
                switcher.query.push(c);
                switcher.error_message = None;
                switcher.reset_selection_to_visible();
                self.state.dirty = true;
            },
            _ => {},
        }
    }

    async fn apply_model_switch_selection(&mut self, rpc: &Arc<RpcClient>) {
        let selected = self.model_switcher.as_ref().and_then(|switcher| {
            let filtered = switcher.filtered_indices();
            if filtered.is_empty() {
                return None;
            }

            let selected_index = if filtered.contains(&switcher.selected) {
                switcher.selected
            } else {
                filtered[0]
            };

            switcher.items.get(selected_index).cloned()
        });

        let Some(selected) = selected else {
            if let Some(switcher) = self.model_switcher.as_mut() {
                switcher.error_message = Some("No model matches the current search.".to_string());
            }
            self.state.dirty = true;
            return;
        };

        let result = rpc
            .call(
                "sessions.patch",
                serde_json::json!({
                    "key": self.state.active_session,
                    "model": selected.model_id,
                }),
            )
            .await;

        match result {
            Ok(_) => {
                self.state.model = Some(selected.model_id.clone());
                self.state.provider = Some(selected.provider_name.clone());
                if let Some(session) = self
                    .state
                    .sessions
                    .iter_mut()
                    .find(|session| session.key == self.state.active_session)
                {
                    session.model = Some(selected.model_id);
                }
                self.model_switcher = None;
                self.state.dirty = true;
            },
            Err(error) => {
                if let Some(switcher) = self.model_switcher.as_mut() {
                    switcher.error_message = Some(format!("Failed to switch model: {error}"));
                }
                self.state.dirty = true;
            },
        }
    }

    async fn handle_insert_key(
        &mut self,
        key: KeyEvent,
        rpc: &Arc<RpcClient>,
        event_tx: &mpsc::UnboundedSender<AppEvent>,
        textarea: &mut TextArea<'_>,
    ) {
        if self.onboarding.is_some() {
            self.handle_onboarding_insert_key(key, rpc, textarea).await;
            return;
        }

        if !self.state.slash_menu_items.is_empty() {
            match (key.code, key.modifiers) {
                (KeyCode::Up, _) => {
                    self.move_slash_menu_selection(false);
                    return;
                },
                (KeyCode::Down, _) => {
                    self.move_slash_menu_selection(true);
                    return;
                },
                (KeyCode::Enter, KeyModifiers::NONE) | (KeyCode::Tab, _) => {
                    self.apply_slash_menu_selection(rpc, event_tx, textarea)
                        .await;
                    return;
                },
                (KeyCode::Esc, _) => {
                    self.clear_slash_menu();
                    return;
                },
                _ => {},
            }
        }

        match (key.code, key.modifiers) {
            (KeyCode::Esc, _) => {
                if self.state.shell_mode_enabled && textarea.lines().join("\n").trim().is_empty() {
                    self.state.shell_mode_enabled = false;
                    self.push_system_message("Command mode disabled.".to_string());
                    self.clear_slash_menu();
                    return;
                }
                self.state.input_mode = InputMode::Normal;
                self.clear_slash_menu();
                self.state.dirty = true;
            },
            (KeyCode::Enter, KeyModifiers::NONE) => {
                // Send message
                let text: String = textarea.lines().join("\n");
                let trimmed = text.trim();
                if !trimmed.is_empty() {
                    if self.handle_slash_command(trimmed, rpc, event_tx).await {
                        *textarea = TextArea::default();
                        textarea.set_placeholder_text("Type a message...");
                        self.clear_slash_menu();
                        self.state.dirty = true;
                        return;
                    }

                    self.state.add_user_message(trimmed.to_owned());
                    self.state.scroll_to_bottom();

                    let outbound = rewrite_for_shell_mode(trimmed, self.state.shell_mode_enabled);
                    rpc.fire_and_forget("chat.send", serde_json::json!({"text": outbound}));

                    // Clear textarea, stay in Insert mode
                    *textarea = TextArea::default();
                    textarea.set_placeholder_text("Type a message...");
                    self.clear_slash_menu();
                }
                self.state.dirty = true;
            },
            (KeyCode::Enter, KeyModifiers::SHIFT) => {
                // Insert newline
                textarea.insert_newline();
                self.update_slash_menu(textarea);
                self.state.dirty = true;
            },
            (KeyCode::Char('c'), KeyModifiers::CONTROL) => {
                if self.state.is_streaming() {
                    rpc.fire_and_forget(
                        "chat.abort",
                        serde_json::json!({"sessionKey": self.state.active_session}),
                    );
                    self.state.active_run_id = None;
                    self.state.thinking_active = false;
                } else {
                    self.state.input_mode = InputMode::Normal;
                }
                self.clear_slash_menu();
                self.state.dirty = true;
            },
            _ => {
                // Forward to textarea
                textarea.input(key);
                self.update_slash_menu(textarea);
                self.state.dirty = true;
            },
        }
    }

    async fn handle_slash_command(
        &mut self,
        text: &str,
        rpc: &Arc<RpcClient>,
        event_tx: &mpsc::UnboundedSender<AppEvent>,
    ) -> bool {
        let Some(command) = parse_slash_command(text) else {
            return false;
        };
        if !should_handle_slash_locally(&command) {
            return false;
        }

        match command.name.as_str() {
            "clear" => {
                rpc.fire_and_forget("chat.clear", serde_json::json!({}));
                self.state.messages.clear();
                self.state.stream_buffer.clear();
                self.state.active_run_id = None;
                self.state.thinking_active = false;
                self.state.thinking_text.clear();
                self.state.token_usage.session_input = 0;
                self.state.token_usage.session_output = 0;
                self.state.scroll_to_bottom();
            },
            "compact" => {
                self.push_system_message("Compacting conversation...".to_string());
                let rpc = Arc::clone(rpc);
                let event_tx = event_tx.clone();
                tokio::spawn(async move {
                    match rpc.call("chat.compact", serde_json::json!({})).await {
                        Ok(_) => {
                            let _ = event_tx.send(AppEvent::SystemMessage(
                                "Conversation compacted.".to_string(),
                            ));
                            spawn_initial_data_load(Arc::clone(&rpc), event_tx.clone());
                        },
                        Err(error) => {
                            let _ = event_tx
                                .send(AppEvent::SystemMessage(format!("Compact failed: {error}")));
                        },
                    }
                });
            },
            "context" => {
                self.push_system_message("Loading context...".to_string());
                let rpc = Arc::clone(rpc);
                let event_tx = event_tx.clone();
                tokio::spawn(async move {
                    match rpc.call("chat.context", serde_json::json!({})).await {
                        Ok(payload) => {
                            let _ = event_tx.send(AppEvent::ContextData(payload));
                        },
                        Err(error) => {
                            let _ = event_tx
                                .send(AppEvent::SystemMessage(format!("Context failed: {error}")));
                        },
                    }
                });
            },
            "help" => {
                self.push_system_message(slash_help_text().to_string());
            },
            "sh" => {
                let normalized = command.args.trim().to_ascii_lowercase();
                if normalized == "off" || normalized == "exit" {
                    self.state.shell_mode_enabled = false;
                    self.push_system_message("Command mode disabled.".to_string());
                } else {
                    self.state.shell_mode_enabled = true;
                    self.push_system_message(
                        "Command mode enabled. Plain messages run as `/sh <command>`. Exit with `/sh off`."
                            .to_string(),
                    );
                }
            },
            _ => {
                return false;
            },
        }

        true
    }

    fn handle_command_key(&mut self, key: KeyEvent, rpc: &Arc<RpcClient>) {
        match key.code {
            KeyCode::Esc => {
                self.state.input_mode = InputMode::Normal;
                self.state.command_buffer.clear();
                self.state.dirty = true;
            },
            KeyCode::Enter => {
                let cmd = std::mem::take(&mut self.state.command_buffer);
                self.execute_command(&cmd, rpc);
                self.state.input_mode = InputMode::Normal;
                self.state.dirty = true;
            },
            KeyCode::Backspace => {
                self.state.command_buffer.pop();
                self.state.dirty = true;
            },
            KeyCode::Char(c) => {
                self.state.command_buffer.push(c);
                self.state.dirty = true;
            },
            _ => {},
        }
    }

    fn execute_command(&mut self, cmd: &str, rpc: &Arc<RpcClient>) {
        let parts: Vec<&str> = cmd.trim().splitn(2, ' ').collect();
        match parts.first().copied() {
            Some("q" | "quit") => self.should_quit = true,
            Some("clear") => {
                rpc.fire_and_forget("chat.clear", serde_json::json!({}));
                self.state.messages.clear();
            },
            Some("model") => {
                if let Some(model_id) = parts.get(1) {
                    rpc.fire_and_forget(
                        "sessions.patch",
                        serde_json::json!({
                            "key": self.state.active_session,
                            "model": model_id
                        }),
                    );
                    self.state.model = Some(model_id.to_string());
                }
            },
            Some("session") => {
                if let Some(key) = parts.get(1) {
                    rpc.fire_and_forget("sessions.switch", serde_json::json!({"key": key}));
                    self.state.active_session = key.to_string();
                    self.state.messages.clear();
                }
            },
            _ => {
                self.state.messages.push(DisplayMessage {
                    role: MessageRole::System,
                    content: format!("Unknown command: {cmd}"),
                    tool_calls: Vec::new(),
                    thinking: None,
                });
            },
        }
    }
}

fn onboarding_modal_open(onboarding: &OnboardingState) -> bool {
    onboarding.llm.configuring.is_some()
        || onboarding.channel.configuring
        || onboarding.editing.is_some()
}

fn should_quit_onboarding(key: KeyEvent, modal_open: bool) -> bool {
    is_force_quit_key(key) || (key.code == KeyCode::Esc && !modal_open)
}

fn is_force_quit_key(key: KeyEvent) -> bool {
    key.code == KeyCode::Char('q')
        || (key.code == KeyCode::Char('c') && key.modifiers.contains(KeyModifiers::CONTROL))
}

#[derive(Debug, Clone)]
struct ModelCatalogEntry {
    provider_name: String,
    model_id: String,
    model_display: String,
}

fn parse_model_list(payload: &Value) -> Vec<ModelCatalogEntry> {
    payload
        .as_array()
        .map(|rows| {
            rows.iter()
                .filter_map(|row| {
                    let model_id = row.get("id").and_then(Value::as_str)?.trim();
                    if model_id.is_empty() {
                        return None;
                    }

                    let provider_name = row
                        .get("provider")
                        .and_then(Value::as_str)
                        .map(str::trim)
                        .filter(|provider| !provider.is_empty())
                        .map(ToOwned::to_owned)
                        .or_else(|| infer_provider_from_model_id(model_id).map(ToOwned::to_owned))
                        .unwrap_or_default();
                    if provider_name.is_empty() {
                        return None;
                    }

                    let model_display = row
                        .get("displayName")
                        .and_then(Value::as_str)
                        .map(str::trim)
                        .filter(|display| !display.is_empty())
                        .map(ToOwned::to_owned)
                        .unwrap_or_else(|| fallback_model_display(model_id));

                    Some(ModelCatalogEntry {
                        provider_name,
                        model_id: model_id.to_string(),
                        model_display,
                    })
                })
                .collect()
        })
        .unwrap_or_default()
}

fn build_model_switch_items(
    providers: &[ProviderEntry],
    models: &[ModelCatalogEntry],
) -> Vec<ModelSwitchItem> {
    let mut seen = HashSet::new();
    let mut items = Vec::new();

    for provider in providers.iter().filter(|provider| provider.configured) {
        let mut has_live_models = false;

        for model in models
            .iter()
            .filter(|model| provider_names_match(&provider.name, &model.provider_name))
        {
            has_live_models = true;
            push_model_switch_item(
                &mut items,
                &mut seen,
                provider,
                &model.model_id,
                &model.model_display,
            );
        }

        if has_live_models {
            continue;
        }

        for model_id in &provider.models {
            if model_id.trim().is_empty() {
                continue;
            }
            push_model_switch_item(
                &mut items,
                &mut seen,
                provider,
                model_id,
                &fallback_model_display(model_id),
            );
        }
    }

    items
}

fn push_model_switch_item(
    items: &mut Vec<ModelSwitchItem>,
    seen: &mut HashSet<(String, String)>,
    provider: &ProviderEntry,
    model_id: &str,
    model_display: &str,
) {
    let normalized_provider = normalize_provider_name(&provider.name);
    let normalized_model = model_id.trim().to_ascii_lowercase();
    if normalized_provider.is_empty() || normalized_model.is_empty() {
        return;
    }

    if !seen.insert((normalized_provider, normalized_model)) {
        return;
    }

    items.push(ModelSwitchItem {
        provider_name: provider.name.clone(),
        provider_display: provider.display_name.clone(),
        model_id: model_id.trim().to_string(),
        model_display: if model_display.trim().is_empty() {
            fallback_model_display(model_id)
        } else {
            model_display.trim().to_string()
        },
    });
}

fn sync_model_switcher_selection(switcher: &mut ModelSwitcherState) {
    let filtered = switcher.filtered_indices();
    if filtered.is_empty() {
        switcher.selected = 0;
        return;
    }
    if !filtered.contains(&switcher.selected) {
        switcher.selected = filtered[0];
    }
}

fn move_model_switcher_selection(switcher: &mut ModelSwitcherState, forward: bool) {
    let filtered = switcher.filtered_indices();
    if filtered.is_empty() {
        switcher.selected = 0;
        return;
    }

    let current_pos = filtered
        .iter()
        .position(|index| *index == switcher.selected)
        .unwrap_or(0);
    let next_pos = if forward {
        (current_pos + 1).min(filtered.len().saturating_sub(1))
    } else {
        current_pos.saturating_sub(1)
    };
    switcher.selected = filtered[next_pos];
}

fn infer_provider_from_model_id(model_id: &str) -> Option<&str> {
    model_id
        .split_once("::")
        .or_else(|| model_id.split_once('/'))
        .or_else(|| model_id.split_once(':'))
        .map(|(provider, _)| provider)
}

fn fallback_model_display(model_id: &str) -> String {
    model_id
        .split_once("::")
        .or_else(|| model_id.split_once('/'))
        .or_else(|| model_id.split_once(':'))
        .map(|(_, model)| model.to_string())
        .unwrap_or_else(|| model_id.to_string())
}

fn provider_names_match(left: &str, right: &str) -> bool {
    normalize_provider_name(left) == normalize_provider_name(right)
}

fn normalize_provider_name(name: &str) -> String {
    let normalized = name.trim().to_ascii_lowercase();
    match normalized.as_str() {
        "z.ai" => "zai".to_string(),
        other => other.to_string(),
    }
}

fn build_slash_menu_items(text: &str) -> Vec<SlashMenuItem> {
    if !text.starts_with('/') || text.chars().any(char::is_whitespace) {
        return Vec::new();
    }
    let filter = text.to_ascii_lowercase();
    SLASH_COMMANDS
        .iter()
        .filter_map(|spec| {
            let command = format!("/{}", spec.name);
            if command.starts_with(&filter) {
                Some(SlashMenuItem {
                    name: spec.name.to_string(),
                    description: spec.description.to_string(),
                })
            } else {
                None
            }
        })
        .collect()
}

fn parse_slash_command(text: &str) -> Option<SlashCommand> {
    let body = text.strip_prefix('/')?.trim();
    if body.is_empty() {
        return None;
    }

    let (name, args) = match body.split_once(char::is_whitespace) {
        Some((name, rest)) => (name, rest.trim()),
        None => (body, ""),
    };
    if name.is_empty() {
        return None;
    }

    Some(SlashCommand {
        name: name.to_ascii_lowercase(),
        args: args.to_string(),
    })
}

fn is_sh_local_toggle(args: &str) -> bool {
    let trimmed = args.trim();
    trimmed.is_empty() || matches!(trimmed.to_ascii_lowercase().as_str(), "on" | "off" | "exit")
}

fn should_handle_slash_locally(command: &SlashCommand) -> bool {
    match command.name.as_str() {
        "clear" | "compact" | "context" | "help" => true,
        "sh" => is_sh_local_toggle(&command.args),
        _ => false,
    }
}

fn rewrite_for_shell_mode(text: &str, shell_mode_enabled: bool) -> String {
    if !shell_mode_enabled {
        return text.to_string();
    }

    if let Some(command) = parse_slash_command(text)
        && command.name == "sh"
    {
        return text.to_string();
    }

    format!("/sh {text}")
}

fn slash_help_text() -> &'static str {
    concat!(
        "Slash commands:\n",
        "/clear  clear session history\n",
        "/compact  summarize history to save tokens\n",
        "/context  show session and project context\n",
        "/sh  enable command mode (/sh off to exit)\n",
        "/help  show this list"
    )
}

fn parse_token_usage(payload: &Value) -> TokenUsage {
    let usage = payload
        .get("tokenUsage")
        .or_else(|| payload.get("usage"))
        .unwrap_or(&Value::Null);
    TokenUsage {
        session_input: usage
            .get("inputTokens")
            .or_else(|| usage.get("sessionInputTokens"))
            .and_then(Value::as_u64)
            .unwrap_or(0),
        session_output: usage
            .get("outputTokens")
            .or_else(|| usage.get("sessionOutputTokens"))
            .and_then(Value::as_u64)
            .unwrap_or(0),
        context_window: usage
            .get("contextWindow")
            .or_else(|| payload.get("contextWindow"))
            .and_then(Value::as_u64)
            .unwrap_or(0),
    }
}

fn parse_context_initial_data(data: &mut InitialData, payload: &Value) {
    if let Some(session) = payload.get("session") {
        data.active_session = session
            .get("key")
            .and_then(Value::as_str)
            .map(ToOwned::to_owned);
        data.model = session
            .get("model")
            .and_then(Value::as_str)
            .map(ToOwned::to_owned);
        data.provider = session
            .get("provider")
            .and_then(Value::as_str)
            .map(ToOwned::to_owned);
    }
    data.token_usage = Some(parse_token_usage(payload));
}

fn format_context_summary(payload: &Value) -> String {
    let session = payload.get("session").unwrap_or(&Value::Null);
    let project = payload.get("project").unwrap_or(&Value::Null);
    let supports_tools = payload
        .get("supportsTools")
        .and_then(Value::as_bool)
        .unwrap_or(true);
    let token_usage = payload.get("tokenUsage").unwrap_or(&Value::Null);
    let sandbox = payload.get("sandbox").unwrap_or(&Value::Null);
    let execution = payload.get("execution").unwrap_or(&Value::Null);

    let session_key = session
        .get("key")
        .and_then(Value::as_str)
        .unwrap_or("unknown");
    let message_count = session
        .get("messageCount")
        .and_then(Value::as_u64)
        .unwrap_or(0);
    let model = session
        .get("model")
        .and_then(Value::as_str)
        .unwrap_or("default");
    let provider = session
        .get("provider")
        .and_then(Value::as_str)
        .unwrap_or("unknown");
    let label = session.get("label").and_then(Value::as_str).unwrap_or("");

    let mut lines = vec![
        "Context".to_string(),
        "Session:".to_string(),
        format!("- Key: {session_key}"),
        format!("- Messages: {message_count}"),
        format!("- Model: {model}"),
        format!("- Provider: {provider}"),
        format!(
            "- Tool support: {}",
            if supports_tools {
                "enabled"
            } else {
                "disabled"
            }
        ),
    ];
    if !label.is_empty() {
        lines.push(format!("- Label: {label}"));
    }

    lines.push(String::new());
    lines.push("Project:".to_string());
    if project.is_null() {
        lines.push("- No project bound to this session.".to_string());
    } else {
        let project_name = project
            .get("label")
            .and_then(Value::as_str)
            .unwrap_or("(unnamed)");
        lines.push(format!("- Name: {project_name}"));
        if let Some(directory) = project.get("directory").and_then(Value::as_str)
            && !directory.is_empty()
        {
            lines.push(format!("- Directory: {directory}"));
        }
        if let Some(system_prompt) = project.get("systemPrompt").and_then(Value::as_str)
            && !system_prompt.is_empty()
        {
            lines.push(format!(
                "- System prompt: {} chars",
                system_prompt.chars().count()
            ));
        }
        let context_files = project
            .get("contextFiles")
            .and_then(Value::as_array)
            .cloned()
            .unwrap_or_default();
        if context_files.is_empty() {
            lines.push("- Context files: none".to_string());
        } else {
            lines.push(format!("- Context files: {}", context_files.len()));
            for file in context_files.iter().take(8) {
                let path = file
                    .get("path")
                    .and_then(Value::as_str)
                    .unwrap_or("(unknown)");
                let size = file.get("size").and_then(Value::as_u64).unwrap_or(0);
                lines.push(format!("  - {path} ({})", format_bytes(size)));
            }
            if context_files.len() > 8 {
                lines.push(format!("  - ... {} more", context_files.len() - 8));
            }
        }
    }

    lines.push(String::new());
    lines.push("Tools:".to_string());
    if !supports_tools {
        lines.push("- Disabled for current model.".to_string());
    } else {
        let tools = payload
            .get("tools")
            .and_then(Value::as_array)
            .cloned()
            .unwrap_or_default();
        if tools.is_empty() {
            lines.push("- No tools registered.".to_string());
        } else {
            let tool_names = tools
                .iter()
                .take(8)
                .filter_map(|tool| tool.get("name").and_then(Value::as_str))
                .collect::<Vec<_>>()
                .join(", ");
            lines.push(format!("- {} tool(s): {tool_names}", tools.len()));
            if tools.len() > 8 {
                lines.push(format!("- ... {} more", tools.len() - 8));
            }
        }

        let skills = payload
            .get("skills")
            .and_then(Value::as_array)
            .cloned()
            .unwrap_or_default();
        if !skills.is_empty() {
            let skill_names = skills
                .iter()
                .take(8)
                .filter_map(|skill| skill.get("name").and_then(Value::as_str))
                .collect::<Vec<_>>()
                .join(", ");
            lines.push(format!("- Skills: {skill_names}"));
            if skills.len() > 8 {
                lines.push(format!("- Skills: ... {} more", skills.len() - 8));
            }
        }

        let mcp_disabled = payload
            .get("mcpDisabled")
            .and_then(Value::as_bool)
            .unwrap_or(false);
        let mcp_servers = payload
            .get("mcpServers")
            .and_then(Value::as_array)
            .cloned()
            .unwrap_or_default();
        if mcp_disabled {
            lines.push("- MCP: disabled for this session.".to_string());
        } else {
            let running = mcp_servers
                .iter()
                .filter(|server| server.get("state").and_then(Value::as_str) == Some("running"))
                .filter_map(|server| server.get("name").and_then(Value::as_str))
                .collect::<Vec<_>>();
            if running.is_empty() {
                lines.push("- MCP: no running servers.".to_string());
            } else {
                lines.push(format!("- MCP running: {}", running.join(", ")));
            }
        }
    }

    lines.push(String::new());
    lines.push("Execution:".to_string());
    let command_route = execution
        .get("mode")
        .and_then(Value::as_str)
        .map(|mode| {
            let label = if mode == "sandbox" {
                "sandboxed"
            } else {
                "host"
            };
            match execution.get("promptSymbol").and_then(Value::as_str) {
                Some(symbol) if !symbol.is_empty() => format!("{label} ({symbol})"),
                _ => label.to_string(),
            }
        })
        .unwrap_or_else(|| "unknown".to_string());
    lines.push(format!("- Command route: {command_route}"));
    lines.push(format!(
        "- Sandbox enabled: {}",
        if sandbox
            .get("enabled")
            .and_then(Value::as_bool)
            .unwrap_or(false)
        {
            "yes"
        } else {
            "no"
        }
    ));
    if let Some(backend) = sandbox.get("backend").and_then(Value::as_str)
        && !backend.is_empty()
    {
        lines.push(format!("- Sandbox backend: {backend}"));
    }
    if let Some(image) = sandbox.get("image").and_then(Value::as_str)
        && !image.is_empty()
    {
        lines.push(format!("- Sandbox image: {image}"));
    }
    if let Some(container) = sandbox.get("containerName").and_then(Value::as_str)
        && !container.is_empty()
    {
        lines.push(format!("- Container: {container}"));
    }

    let session_input = token_usage
        .get("inputTokens")
        .and_then(Value::as_u64)
        .unwrap_or(0);
    let session_output = token_usage
        .get("outputTokens")
        .and_then(Value::as_u64)
        .unwrap_or(0);
    let session_total = token_usage
        .get("total")
        .and_then(Value::as_u64)
        .unwrap_or(session_input.saturating_add(session_output));
    let current_input = token_usage
        .get("currentInputTokens")
        .and_then(Value::as_u64)
        .unwrap_or(session_input);
    let current_output = token_usage
        .get("currentOutputTokens")
        .and_then(Value::as_u64)
        .unwrap_or(0);
    let current_total = token_usage
        .get("currentTotal")
        .and_then(Value::as_u64)
        .unwrap_or(current_input.saturating_add(current_output));
    let estimated_next_input = token_usage
        .get("estimatedNextInputTokens")
        .and_then(Value::as_u64)
        .unwrap_or(current_input);
    let context_window = token_usage
        .get("contextWindow")
        .and_then(Value::as_u64)
        .unwrap_or(0);

    lines.push(String::new());
    lines.push("Tokens:".to_string());
    lines.push(format!(
        "- Session: in {}, out {}, total {}",
        ui::common::format_count(session_input),
        ui::common::format_count(session_output),
        ui::common::format_count(session_total)
    ));
    lines.push(format!(
        "- Current request: in {}, out {}, total {}",
        ui::common::format_count(current_input),
        ui::common::format_count(current_output),
        ui::common::format_count(current_total)
    ));
    lines.push(format!(
        "- Estimated next input: {}",
        ui::common::format_count(estimated_next_input)
    ));
    if context_window > 0 {
        let pct_used = ((estimated_next_input as f64 / context_window as f64) * 100.0).round();
        lines.push(format!(
            "- Context usage: {}% of {}",
            pct_used.clamp(0.0, 100.0) as u64,
            ui::common::format_count(context_window)
        ));
    }

    lines.join("\n")
}

fn format_bytes(size: u64) -> String {
    const KB: u64 = 1024;
    const MB: u64 = KB * 1024;
    const GB: u64 = MB * 1024;

    if size >= GB {
        format!("{:.1} GB", size as f64 / GB as f64)
    } else if size >= MB {
        format!("{:.1} MB", size as f64 / MB as f64)
    } else if size >= KB {
        format!("{:.1} KB", size as f64 / KB as f64)
    } else {
        format!("{size} B")
    }
}

/// Load initial data (sessions, history, context) in a background task.
/// Results are sent back to the event loop via `event_tx`.
fn spawn_initial_data_load(rpc: Arc<RpcClient>, event_tx: mpsc::UnboundedSender<AppEvent>) {
    tokio::spawn(async move {
        let mut data = InitialData::default();

        // Run all 3 RPC calls concurrently.
        let (sessions_res, history_res, context_res) = tokio::join!(
            rpc.call("sessions.list", serde_json::json!({})),
            rpc.call("chat.history", serde_json::json!({})),
            rpc.call("chat.context", serde_json::json!({})),
        );

        // Parse sessions
        if let Ok(sessions) = sessions_res {
            if let Some(arr) = sessions.as_array() {
                data.sessions = Some(
                    arr.iter()
                        .filter_map(|s| {
                            let key = s.get("key").and_then(|v| v.as_str())?;
                            Some(SessionEntry {
                                key: key.into(),
                                label: s.get("label").and_then(|v| v.as_str()).map(String::from),
                                model: s.get("model").and_then(|v| v.as_str()).map(String::from),
                                message_count: s
                                    .get("message_count")
                                    .and_then(|v| v.as_u64())
                                    .unwrap_or(0),
                                replying: s
                                    .get("replying")
                                    .and_then(|v| v.as_bool())
                                    .unwrap_or(false),
                            })
                        })
                        .collect(),
                );
            }
        } else if let Err(e) = sessions_res {
            warn!(error = %e, "failed to load sessions");
        }

        // Parse chat history
        if let Ok(history) = history_res {
            if let Some(arr) = history.as_array() {
                data.messages = Some(
                    arr.iter()
                        .filter_map(|msg| {
                            let role = msg.get("role").and_then(|v| v.as_str())?;
                            let content = msg
                                .get("content")
                                .and_then(|v| v.as_str())
                                .unwrap_or("")
                                .to_owned();
                            let role = match role {
                                "user" => MessageRole::User,
                                "assistant" => MessageRole::Assistant,
                                _ => MessageRole::System,
                            };
                            Some(DisplayMessage {
                                role,
                                content,
                                tool_calls: Vec::new(),
                                thinking: None,
                            })
                        })
                        .collect(),
                );
            }
        } else if let Err(e) = history_res {
            warn!(error = %e, "failed to load chat history");
        }

        // Parse context
        if let Ok(ctx) = context_res {
            parse_context_initial_data(&mut data, &ctx);
        } else if let Err(e) = context_res {
            debug!(error = %e, "failed to load context");
        }

        let _ = event_tx.send(AppEvent::InitialData(data));
    });
}

#[cfg(test)]
mod tests {
    use {
        super::*,
        crate::{
            onboarding::{OnboardingState, ProviderEntry},
            state::ModelSwitcherState,
        },
    };

    #[test]
    fn onboarding_escape_quits_only_without_modal() {
        assert!(should_quit_onboarding(
            KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE),
            false
        ));
        assert!(!should_quit_onboarding(
            KeyEvent::new(KeyCode::Esc, KeyModifiers::NONE),
            true
        ));
    }

    #[test]
    fn onboarding_force_quit_keys_always_quit() {
        assert!(should_quit_onboarding(
            KeyEvent::new(KeyCode::Char('q'), KeyModifiers::NONE),
            false
        ));
        assert!(should_quit_onboarding(
            KeyEvent::new(KeyCode::Char('c'), KeyModifiers::CONTROL),
            true
        ));
        assert!(!should_quit_onboarding(
            KeyEvent::new(KeyCode::Char('j'), KeyModifiers::NONE),
            false
        ));
    }

    #[test]
    fn channel_config_modal_counts_as_open_modal() {
        let mut onboarding = OnboardingState::new(false, false, true, None);
        onboarding.channel.configuring = true;
        assert!(onboarding_modal_open(&onboarding));
    }

    #[test]
    fn parse_model_list_uses_provider_field_and_fallback_display() {
        let payload = serde_json::json!([
            {
                "id": "openai/gpt-5",
                "provider": "openai",
                "displayName": "GPT-5"
            },
            {
                "id": "anthropic::claude-sonnet-4",
                "displayName": ""
            }
        ]);

        let parsed = parse_model_list(&payload);
        assert_eq!(parsed.len(), 2);
        assert_eq!(parsed[0].provider_name, "openai");
        assert_eq!(parsed[0].model_display, "GPT-5");
        assert_eq!(parsed[1].provider_name, "anthropic");
        assert_eq!(parsed[1].model_display, "claude-sonnet-4");
    }

    #[test]
    fn build_model_switch_items_uses_live_models_then_provider_saved_models() {
        let providers = vec![
            ProviderEntry {
                name: "openai".into(),
                display_name: "OpenAI".into(),
                auth_type: "api-key".into(),
                configured: true,
                default_base_url: None,
                base_url: None,
                models: vec!["openai/gpt-4.1".into()],
                requires_model: false,
                key_optional: false,
            },
            ProviderEntry {
                name: "anthropic".into(),
                display_name: "Anthropic".into(),
                auth_type: "api-key".into(),
                configured: true,
                default_base_url: None,
                base_url: None,
                models: vec!["anthropic/claude-sonnet-4".into()],
                requires_model: false,
                key_optional: false,
            },
            ProviderEntry {
                name: "openrouter".into(),
                display_name: "OpenRouter".into(),
                auth_type: "api-key".into(),
                configured: false,
                default_base_url: None,
                base_url: None,
                models: vec!["openrouter/meta-llama-3.1-8b-instruct".into()],
                requires_model: false,
                key_optional: false,
            },
        ];

        let models = vec![ModelCatalogEntry {
            provider_name: "openai".into(),
            model_id: "openai/gpt-5".into(),
            model_display: "GPT-5".into(),
        }];

        let items = build_model_switch_items(&providers, &models);
        assert_eq!(items.len(), 2);
        assert_eq!(items[0].provider_name, "openai");
        assert_eq!(items[0].model_id, "openai/gpt-5");
        assert_eq!(items[1].provider_name, "anthropic");
        assert_eq!(items[1].model_id, "anthropic/claude-sonnet-4");
    }

    #[test]
    fn provider_alias_matching_supports_zai() {
        assert!(provider_names_match("z.ai", "zai"));
        assert!(provider_names_match("ZAI", "z.ai"));
    }

    #[test]
    fn model_switcher_selection_stays_in_filtered_list() {
        let mut switcher = ModelSwitcherState {
            query: "claude".into(),
            selected: 0,
            items: vec![
                ModelSwitchItem {
                    provider_name: "openai".into(),
                    provider_display: "OpenAI".into(),
                    model_id: "openai/gpt-5".into(),
                    model_display: "GPT-5".into(),
                },
                ModelSwitchItem {
                    provider_name: "anthropic".into(),
                    provider_display: "Anthropic".into(),
                    model_id: "anthropic/claude-sonnet-4".into(),
                    model_display: "Claude Sonnet 4".into(),
                },
            ],
            error_message: None,
        };

        sync_model_switcher_selection(&mut switcher);
        assert_eq!(switcher.selected, 1);

        move_model_switcher_selection(&mut switcher, true);
        assert_eq!(switcher.selected, 1);
    }

    #[test]
    fn parse_slash_command_extracts_name_and_args() {
        let command = match parse_slash_command("/context") {
            Some(command) => command,
            None => panic!("command should parse"),
        };
        assert_eq!(command.name, "context");
        assert_eq!(command.args, "");

        let command = match parse_slash_command("/SH echo hello") {
            Some(command) => command,
            None => panic!("command should parse"),
        };
        assert_eq!(command.name, "sh");
        assert_eq!(command.args, "echo hello");

        assert!(parse_slash_command("context").is_none());
        assert!(parse_slash_command("/").is_none());
    }

    #[test]
    fn slash_menu_matches_prefix_without_whitespace() {
        let all = build_slash_menu_items("/");
        assert_eq!(all.len(), 5);

        let filtered = build_slash_menu_items("/co");
        let names = filtered
            .iter()
            .map(|item| item.name.as_str())
            .collect::<Vec<_>>();
        assert_eq!(names, vec!["compact", "context"]);

        assert!(build_slash_menu_items("/co arg").is_empty());
        assert!(build_slash_menu_items("context").is_empty());
    }

    #[test]
    fn slash_local_routing_matches_web_behavior() {
        assert!(should_handle_slash_locally(&SlashCommand {
            name: "clear".to_string(),
            args: String::new(),
        }));
        assert!(should_handle_slash_locally(&SlashCommand {
            name: "context".to_string(),
            args: String::new(),
        }));
        assert!(should_handle_slash_locally(&SlashCommand {
            name: "sh".to_string(),
            args: "off".to_string(),
        }));
        assert!(!should_handle_slash_locally(&SlashCommand {
            name: "sh".to_string(),
            args: "uname -a".to_string(),
        }));
    }

    #[test]
    fn shell_mode_rewrite_prefixes_non_sh_messages() {
        assert_eq!(rewrite_for_shell_mode("echo hi", true), "/sh echo hi");
        assert_eq!(rewrite_for_shell_mode("/clear", true), "/sh /clear");
        assert_eq!(rewrite_for_shell_mode("/sh uname -a", true), "/sh uname -a");
        assert_eq!(rewrite_for_shell_mode("echo hi", false), "echo hi");
    }

    #[test]
    fn parse_context_initial_data_reads_token_usage() {
        let payload = serde_json::json!({
            "session": {
                "key": "main",
                "model": "openai/gpt-5",
                "provider": "openai"
            },
            "tokenUsage": {
                "inputTokens": 1200,
                "outputTokens": 300,
                "contextWindow": 200000
            }
        });
        let mut data = InitialData::default();
        parse_context_initial_data(&mut data, &payload);

        assert_eq!(data.active_session.as_deref(), Some("main"));
        assert_eq!(data.model.as_deref(), Some("openai/gpt-5"));
        assert_eq!(data.provider.as_deref(), Some("openai"));
        assert_eq!(
            data.token_usage.as_ref().map(|usage| usage.session_input),
            Some(1200)
        );
        assert_eq!(
            data.token_usage.as_ref().map(|usage| usage.session_output),
            Some(300)
        );
        assert_eq!(
            data.token_usage.as_ref().map(|usage| usage.context_window),
            Some(200000)
        );
    }

    #[test]
    fn format_context_summary_includes_core_sections() {
        let payload = serde_json::json!({
            "session": {
                "key": "main",
                "messageCount": 5,
                "model": "openai/gpt-5",
                "provider": "openai"
            },
            "project": {
                "label": "repo",
                "directory": "/tmp/repo",
                "contextFiles": [
                    { "path": "README.md", "size": 1024 }
                ]
            },
            "tools": [
                { "name": "exec" },
                { "name": "fs_read" }
            ],
            "skills": [
                { "name": "skill-installer" }
            ],
            "mcpServers": [
                { "name": "filesystem", "state": "running" }
            ],
            "sandbox": {
                "enabled": true,
                "backend": "docker"
            },
            "execution": {
                "mode": "sandbox",
                "promptSymbol": "#"
            },
            "tokenUsage": {
                "inputTokens": 1000,
                "outputTokens": 500,
                "total": 1500,
                "currentInputTokens": 900,
                "currentOutputTokens": 100,
                "currentTotal": 1000,
                "estimatedNextInputTokens": 950,
                "contextWindow": 10000
            }
        });

        let summary = format_context_summary(&payload);
        assert!(summary.contains("Context"));
        assert!(summary.contains("Session:"));
        assert!(summary.contains("Project:"));
        assert!(summary.contains("Tools:"));
        assert!(summary.contains("Execution:"));
        assert!(summary.contains("Tokens:"));
        assert!(summary.contains("MCP running: filesystem"));
    }
}
